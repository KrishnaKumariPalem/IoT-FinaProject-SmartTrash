/*
* SCHEMATIC http://i.imgur.com/plwZbFa.png
*
 * Connecting ESP8266 (ESP-12) and Nokia 5110 LCD
 * www.KendrickTabi.com
 * http://www.kendricktabi.com/2015/08/esp8266-and-nokia-5110-lcd.html
 */

#include <ESP8266WiFi.h>
#include <ArduinoJson.h>
#include <SPI.h>
#include <WiFiClient.h>
#include <Temboo.h>

#define PIN_SCE   12 //pin GPIO12 ON ESP , pin SCE ON LCD
#define PIN_RESET 2 //pin GPI02 on ESP , pin RST on LCD
#define PIN_DC    14 //pin GPIO14 on ESP , pin DC on LCD
#define PIN_SDIN  4 //pin GPIO4 on ESP , pin SDIN on LCD
#define PIN_SCLK  5 //pin GPIO5 on ESP  , pin SLCK on LCD

#define TRIGGER 10
#define ECHO    9

//The DC pin tells the LCD if we are sending a command or data
#define LCD_COMMAND 0 
#define LCD_DATA  1

//You may find a different size screen, but this one is 84 by 48 pixels
#define LCD_X     84
#define LCD_Y     48

// Color definitions
#define BLACK    0x0000
#define BLUE     0x001F
#define RED      0xF800
#define GREEN    0x07E0
#define CYAN     0x07FF
#define MAGENTA  0xF81F
#define YELLOW   0xFFE0 
#define WHITE    0xFFFF

#define TEMBOO_ACCOUNT "pnvkrishnakumari"  // Your Temboo account name 
#define TEMBOO_APP_KEY_NAME "myFirstApp"  // Your Temboo app key name
#define TEMBOO_APP_KEY "JmHSxpZSGAKvO0vdqgoxIYuMaIA31ndT"  // Your Temboo app key

WiFiClient client;

int numRuns = 1;   // Execution count, so this doesn't run forever
int maxRuns = 10;   // Maximum number of times the Choreo should be executed
int ln = 0;
String TimeDate = "";
String eTime = "";
String eDate = "";

char disp_tab[]={'0','1','2','3','4','5','6','7','8','9'};
const char* host = "128.138.141.172";

//This table contains the hex values that represent pixels
//for a font that is 5 pixels wide and 8 pixels high
static const byte ASCII[][5] = {
  {0x00, 0x00, 0x00, 0x00, 0x00} // 20  
  ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 21 !
  ,{0x00, 0x07, 0x00, 0x07, 0x00} // 22 "
  ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 23 #
  ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 24 $
  ,{0x23, 0x13, 0x08, 0x64, 0x62} // 25 %
  ,{0x36, 0x49, 0x55, 0x22, 0x50} // 26 &
  ,{0x00, 0x05, 0x03, 0x00, 0x00} // 27 '
  ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 28 (
  ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 29 )
  ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 2a *
  ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 2b +
  ,{0x00, 0x50, 0x30, 0x00, 0x00} // 2c ,
  ,{0x08, 0x08, 0x08, 0x08, 0x08} // 2d -
  ,{0x00, 0x60, 0x60, 0x00, 0x00} // 2e .
  ,{0x20, 0x10, 0x08, 0x04, 0x02} // 2f /
  ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 30 0
  ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 31 1
  ,{0x42, 0x61, 0x51, 0x49, 0x46} // 32 2
  ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 33 3
  ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 34 4
  ,{0x27, 0x45, 0x45, 0x45, 0x39} // 35 5
  ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 36 6
  ,{0x01, 0x71, 0x09, 0x05, 0x03} // 37 7
  ,{0x36, 0x49, 0x49, 0x49, 0x36} // 38 8
  ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 39 9
  ,{0x00, 0x36, 0x36, 0x00, 0x00} // 3a :
  ,{0x00, 0x56, 0x36, 0x00, 0x00} // 3b ;
  ,{0x08, 0x14, 0x22, 0x41, 0x00} // 3c <
  ,{0x14, 0x14, 0x14, 0x14, 0x14} // 3d =
  ,{0x00, 0x41, 0x22, 0x14, 0x08} // 3e >
  ,{0x02, 0x01, 0x51, 0x09, 0x06} // 3f ?
  ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 40 @
  ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 41 A
  ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 42 B
  ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 43 C
  ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 44 D
  ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 45 E
  ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 46 F
  ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 47 G
  ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 48 H
  ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 49 I
  ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 4a J
  ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 4b K
  ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 4c L
  ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 4d M
  ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 4e N
  ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 4f O
  ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 50 P
  ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 51 Q
  ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 52 R
  ,{0x46, 0x49, 0x49, 0x49, 0x31} // 53 S
  ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 54 T
  ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 55 U
  ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 56 V
  ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 57 W
  ,{0x63, 0x14, 0x08, 0x14, 0x63} // 58 X
  ,{0x07, 0x08, 0x70, 0x08, 0x07} // 59 Y
  ,{0x61, 0x51, 0x49, 0x45, 0x43} // 5a Z
  ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 5b [
  ,{0x02, 0x04, 0x08, 0x10, 0x20} // 5c 
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 5d ]
  ,{0x04, 0x02, 0x01, 0x02, 0x04} // 5e ^
  ,{0x40, 0x40, 0x40, 0x40, 0x40} // 5f _
  ,{0x00, 0x01, 0x02, 0x04, 0x00} // 60 `
  ,{0x20, 0x54, 0x54, 0x54, 0x78} // 61 a
  ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 62 b
  ,{0x38, 0x44, 0x44, 0x44, 0x20} // 63 c
  ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 64 d
  ,{0x38, 0x54, 0x54, 0x54, 0x18} // 65 e
  ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 66 f
  ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 67 g
  ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 68 h
  ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 69 i
  ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 6a j 
  ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 6b k
  ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 6c l
  ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 6d m
  ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 6e n
  ,{0x38, 0x44, 0x44, 0x44, 0x38} // 6f o
  ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 70 p
  ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 71 q
  ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 72 r
  ,{0x48, 0x54, 0x54, 0x54, 0x20} // 73 s
  ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 74 t
  ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 75 u
  ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 76 v
  ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 77 w
  ,{0x44, 0x28, 0x10, 0x28, 0x44} // 78 x
  ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 79 y
  ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 7a z
  ,{0x00, 0x08, 0x36, 0x41, 0x00} // 7b {
  ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 7c |
  ,{0x00, 0x41, 0x36, 0x08, 0x00} // 7d }
  ,{0x10, 0x08, 0x08, 0x10, 0x08} // 7e ~
  ,{0x78, 0x46, 0x41, 0x46, 0x78} // 7f DEL
};

// Hex values that represent Bitcoin logo
char bitcoin[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x60, 0x70,
0x18, 0x18, 0x18, 0x0C, 0x0C, 0x06, 0x06, 0x06, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x06, 0x06,
0x06, 0x0C, 0x0C, 0x18, 0x18, 0x18, 0x70, 0x60, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0x38, 0x1E, 0x07, 0x03,
0x01, 0x80, 0xC0, 0xF0, 0xF8, 0xF8, 0x3E, 0x3E, 0x3E, 0x3F, 0x3F, 0x03, 0x03, 0x03, 0x3F, 0x03,
0x03, 0x03, 0x3F, 0x3F, 0x7F, 0x7E, 0xFE, 0xFE, 0xF8, 0xF8, 0xF0, 0xC0, 0x80, 0x01, 0x03, 0x07,
0x1E, 0x38, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFC, 0x1F, 0x03,
0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00,
0x00, 0x00, 0x3E, 0x3E, 0x3E, 0x3E, 0x1C, 0x00, 0x00, 0x00, 0x40, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x03, 0x1F, 0xFC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x3F, 0xFC, 0xC0, 0x00, 0x00, 0x00, 0x07, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x3E, 0x1E, 0x00, 0x00, 0x00, 0x00,
0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x00, 0xC0, 0xFC, 0x3F, 0x03, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x1E, 0x3C, 0x60, 0xE0, 0x80, 0x80, 0x03, 0x07,
0x0F, 0x1F, 0x3E, 0x3E, 0x7E, 0x7E, 0x7E, 0x60, 0xE0, 0xE0, 0xFE, 0xE0, 0xE0, 0xE0, 0x7E, 0x7E,
0x7E, 0x7F, 0x3F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x80, 0x80, 0xE0, 0x60, 0x3C, 0x1E, 0x03, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x03, 0x06, 0x06, 0x0C, 0x0C, 0x18, 0x18, 0x18, 0x30, 0x30, 0x30, 0x20, 0x60, 0x60, 0x60,
0x60, 0x20, 0x30, 0x30, 0x30, 0x18, 0x18, 0x18, 0x0C, 0x0C, 0x06, 0x06, 0x03, 0x01, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

//const char* ssid     = "WIFI_AP_SSID_TO_CONNCT";     // insert your SSID
//const char* password = "WIFI_PASS"; // insert your password


//There are two memory banks in the LCD, data/RAM and commands. This 
//function sets the DC pin high or low depending, and then sends
//the data byte
void LCDWrite(byte data_or_command, byte data) {
  digitalWrite(PIN_DC, data_or_command); //Tell the LCD that we are writing either to data or a command

  //Send the data
  digitalWrite(PIN_SCE, LOW);
  shiftOut(PIN_SDIN, PIN_SCLK, MSBFIRST, data);
  digitalWrite(PIN_SCE, HIGH);
}


void gotoXY(int x, int y) {
  LCDWrite(0, 0x80 | x);  // Column  x - range: 0 to 84
  LCDWrite(0, 0x40 | y);  // Row     y - range: 0 to 5
}

//This takes a large array of bits and sends them to the LCD
void LCDBitmap(char my_array[]){
  for (int index = 0 ; index < (LCD_X * LCD_Y / 8) ; index++)
    LCDWrite(LCD_DATA, my_array[index]);
}

//This function takes in a character, looks it up in the font table/array
//And writes it to the screen
//Each character is 8 bits tall and 5 bits wide. We pad one blank column of
//pixels on each side of the character for readability.
void LCDCharacter(char character) {
  LCDWrite(LCD_DATA, 0x00); //Blank vertical line padding

  for (int index = 0 ; index < 5 ; index++)
    LCDWrite(LCD_DATA, ASCII[character - 0x20][index]);
    //0x20 is the ASCII character for Space (' '). The font table starts with this character

  LCDWrite(LCD_DATA, 0x00); //Blank vertical line padding
}


//Given a string of characters, one by one is passed to the LCD
void LCDString(char *characters) {
  while (*characters)
    LCDCharacter(*characters++);
}



//Clears the LCD by writing zeros to the entire screen
void LCDClear(void) {
  for (int index = 0 ; index < (LCD_X * LCD_Y / 8) ; index++)
    LCDWrite(LCD_DATA, 0x00);
    
  gotoXY(0, 0); //After we clear the display, return to the home position
}

void drawRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color);
void fillRect(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t color);

//This sends the magical commands to the PCD8544
void LCDInit(void) {

  //Configure control pins
  pinMode(PIN_SCE, OUTPUT);
  pinMode(PIN_RESET, OUTPUT);
  pinMode(PIN_DC, OUTPUT);
  pinMode(PIN_SDIN, OUTPUT);
  pinMode(PIN_SCLK, OUTPUT);

  //Ultrasonic sensor setup
  Serial.begin (115200);
  pinMode(TRIGGER, OUTPUT);
  pinMode(ECHO, INPUT);
  pinMode(BUILTIN_LED, OUTPUT);
  
  //Reset the LCD to a known state
  digitalWrite(PIN_RESET, LOW);
  digitalWrite(PIN_RESET, HIGH);

  LCDWrite(LCD_COMMAND, 0x21); //Tell LCD that extended commands follow
  LCDWrite(LCD_COMMAND, 0xB0); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
  LCDWrite(LCD_COMMAND, 0x04); //Set Temp coefficent
  LCDWrite(LCD_COMMAND, 0x14); //LCD bias mode 1:48: Try 0x13 or 0x14

  LCDWrite(LCD_COMMAND, 0x20); //We must send 0x20 before modifying the display control mode
  LCDWrite(LCD_COMMAND, 0x0C); //Set display control, normal mode. 0x0D for inverse
}




void setup() {
  
  LCDInit(); //Init the LCD
  
  LCDClear();
  LCDBitmap(bitcoin); // display Bitcoin Logo
  delay(3000);

  LCDClear();
  gotoXY(0, 2);
  LCDString("iot-m2m.blogspot.com");
  delay(3000);

  LCDClear();
  gotoXY(0, 0);
  LCDString(" {Bitcoin!} ");
  gotoXY(0, 2);
  LCDString("Connecting  ");
  LCDString("to WiFi");
  
  WiFi.begin("221girls", "3308619639");
  
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    LCDString(".");
  }
  
  LCDClear();
  gotoXY(0, 2);
  Serial.println("wifi connected");
  LCDString("    WiFi    "); 
  LCDString(" Connected! "); 
  delay(2000);
  LCDClear();
}

void dispcountt(int count)
{
  //LCDCharacter(disp_tab[count/10000]);
  //LCDCharacter(disp_tab[count/1000%10]);
  LCDCharacter(disp_tab[count/100%10]);
  LCDCharacter(disp_tab[count%100/10]);
  LCDCharacter(disp_tab[count%10]);
}

void loop() {
  //Code for distance reading
  float duration, distance;
  float percFilled;
  const int httpPort = 13;
  if (!client.connect(host, httpPort)) {
    Serial.println("connection failed");
    return;
  }
  // This will send the request to the server
  client.print("HEAD / HTTP/1.1\r\nAccept: */*\r\nUser-Agent: Mozilla/4.0 (compatible; ESP8266 NodeMcu Lua;)\r\n\r\n");

  delay(100);

  // Read all the lines of the reply from server and print them to Serial
  // expected line is like : Date: Thu, 01 Jan 2015 22:00:14 GMT
  char buffer[12];
  String dateTime = "";

while(client.available())
  {
    String line = client.readStringUntil('\r');

    if (line.indexOf("Date") != -1)
    {
      Serial.print("=====>");
    } else
    {
      // Serial.print(line);
      // date starts at pos 7
      eDate = line.substring(10,15);
      //eDate.toCharArray(buffer, 10);
      Serial.println(eDate);
      eTime = line.substring(16, 24);
      Serial.println(eTime);
      // time starts at pos 14
      //TimeDate = line.substring(7, 15);
      
      //TimeDate = line.substring(16, 24);
     // TimeDate.toCharArray(buffer, 10);
    }
  }
  
  digitalWrite(TRIGGER, LOW);  
  delayMicroseconds(20); 
  
  digitalWrite(TRIGGER, HIGH);
  delayMicroseconds(50); 
  
  digitalWrite(TRIGGER, LOW);
  duration = pulseIn(ECHO, HIGH);
  distance = (duration/2) / 29.1;
  percFilled = 100.0 - ((distance/13.7) * 100.0);
  
  Serial.print(distance);
  Serial.println(" cm");
  
 if (numRuns <= maxRuns) {
    Serial.println("Running AppendRow & SendSMS - Run #" + String(numRuns++));

    TembooChoreo AppendRowChoreo(client);
    TembooChoreo SendSMSChoreo(client);

    // Invoke the Temboo client
    AppendRowChoreo.begin();
    SendSMSChoreo.begin();

    // Set Temboo account credentials
    AppendRowChoreo.setAccountName(TEMBOO_ACCOUNT);
    AppendRowChoreo.setAppKeyName(TEMBOO_APP_KEY_NAME);
    AppendRowChoreo.setAppKey(TEMBOO_APP_KEY);

    SendSMSChoreo.setAccountName(TEMBOO_ACCOUNT);
    SendSMSChoreo.setAppKeyName(TEMBOO_APP_KEY_NAME);
    SendSMSChoreo.setAppKey(TEMBOO_APP_KEY);

   // Set Choreo inputs
    String AuthTokenValue = "1f4e0c95f4fb9e081a6e2cf877f73855";
    SendSMSChoreo.addInput("AuthToken", AuthTokenValue);
    String ToValue = "+13308619639";
    SendSMSChoreo.addInput("To", ToValue);
    String FromValue = "+12342941382";
    SendSMSChoreo.addInput("From", FromValue);
    String BodyValue = "Alert \ndepth: "+String(distance)+"\nPercentage Filled: "+String(percFilled);
    SendSMSChoreo.addInput("Body", BodyValue);
   /* if(distance>=3.5){
     String BodyValue = "Alert \ndepth: "+String(distance)+"\nPercentage Filled: "+String(percFilled);
    SendSMSChoreo.addInput("Body", BodyValue);
    }
    if(distance<3.5){
      String BodyValue = "Alert \ndepth: "+String(distance)+"\nPercentage Filled: "+String(percFilled)+"\nBin is alomost filled. Please remove it";
    SendSMSChoreo.addInput("Body", BodyValue);
    }*/
    String AccountSIDValue = "ACe82b08d7585f5537552a943614f32414";
    SendSMSChoreo.addInput("AccountSID", AccountSIDValue);

    // Identify the Choreo to run
    SendSMSChoreo.setChoreo("/Library/Twilio/SMSMessages/SendSMS");

    // Run the Choreo; when results are available, print them to serial
    SendSMSChoreo.run();

    gotoXY(0, 2);
    LCDString("Please wait.."); 
    delay(5000);
    LCDClear();
    LCDString("Status SMS"); 
    LCDString(" sent to"); 
    LCDString(" 330-861-9639");
    delay(5000);
    LCDClear();
    // Set Choreo inputs
    String SpreadsheetTitleValue = "SmartTrashData";
    AppendRowChoreo.addInput("SpreadsheetTitle", SpreadsheetTitleValue);
   
    if(distance>=3.5){
    LCDString("Depth is:");
    dispcountt(distance);
    //gotoXY(0, 2);
    LCDString(" cm");
    delay(5000);
    LCDClear();
     LCDString("% filled is:");
    dispcountt(percFilled);
    //gotoXY(0, 2);
    LCDString(" %");
    
    String RowDataValue = String(eDate)+"-2016,"+String(eTime)+","+String(distance)+","+String(percFilled);
    AppendRowChoreo.addInput("RowData", RowDataValue);
    String RefreshTokenValue = "1/ib2hSoilI4BzMK3J3_Qla05jwZZoMzmnJjWCKPOYo64";
    AppendRowChoreo.addInput("RefreshToken", RefreshTokenValue);
    String ClientSecretValue = "LgWEcd00XmPxbiXMDV4hxtyU";
    AppendRowChoreo.addInput("ClientSecret", ClientSecretValue);
    String ClientIDValue = "988745903266-fdf0t99o9jhupfl7btkqj6qhgt7jmac9.apps.googleusercontent.com";
    AppendRowChoreo.addInput("ClientID", ClientIDValue);
    // Identify the Choreo to run
    AppendRowChoreo.setChoreo("/Library/Google/Spreadsheets/AppendRow");

    // Run the Choreo; when results are available, print them to serial
    AppendRowChoreo.run();

    while(AppendRowChoreo.available()) {
      char c = AppendRowChoreo.read();
      Serial.print(c);    
    }
    }
    if(distance<3.5){
       LCDString("Depth is:");
    dispcountt(distance);
    //gotoXY(0, 2);
    LCDString(" cm");
    delay(5000);
    LCDClear();
     LCDString("% filled is:");
    dispcountt(percFilled);
    //gotoXY(0, 2);
    LCDString(" %");
    delay(5000);
    LCDClear();
    Serial.println("Bin is almost filled");
    LCDString("Bin is almost filled");
    String RowDataValue = String(eDate)+"-2016,"+String(eTime)+","+String(distance)+","+String(percFilled)+","+"Bin is almost filled";
    AppendRowChoreo.addInput("RowData", RowDataValue);
    String RefreshTokenValue = "1/ib2hSoilI4BzMK3J3_Qla05jwZZoMzmnJjWCKPOYo64";
    AppendRowChoreo.addInput("RefreshToken", RefreshTokenValue);
    String ClientSecretValue = "LgWEcd00XmPxbiXMDV4hxtyU";
    AppendRowChoreo.addInput("ClientSecret", ClientSecretValue);
    String ClientIDValue = "988745903266-fdf0t99o9jhupfl7btkqj6qhgt7jmac9.apps.googleusercontent.com";
    AppendRowChoreo.addInput("ClientID", ClientIDValue);
    // Identify the Choreo to run
    AppendRowChoreo.setChoreo("/Library/Google/Spreadsheets/AppendRow");

    // Run the Choreo; when results are available, print them to serial
    AppendRowChoreo.run();

    while(AppendRowChoreo.available()) {
      char c = AppendRowChoreo.read();
      Serial.print(c);
    } 
    }    
    AppendRowChoreo.close();

     while(SendSMSChoreo.available()) {
      char c = SendSMSChoreo.read();
      Serial.print(c);
    }
    SendSMSChoreo.close();
  }
  
  delay(10000);
  LCDClear();  
  Serial.println("\nWaiting...\n");
  delay(30000); // wait 30 seconds between AppendRow calls
}
